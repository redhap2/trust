```{r}
setwd("~/Working paper/Trust/Script")
getwd()
```

```{r}
library(raster)
library(rgdal)
library(dplyr)
select <- dplyr::select
library(magrittr)
library(sf)
library(exactextractr)
library(ggplot2)
```

```{r}
tiff_file <- "C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins/Mobile Coverage Explorer v2019 - GeoTIFF/Data_MCE/ByCountry/MCE_2G/MCE_BJ2G_2019.tif"
```

```{r}
gg <- raster(tiff_file)

print(gg)

gg_wgs84 <- projectRaster(gg, crs = CRS("+proj=longlat +datum=WGS84"))

print(gg_wgs84)
```

```{r}
rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

gg_wgs84_recode <- calc(gg_wgs84, fun=rc)

plot(gg_wgs84_recode)

rm(coords, gg, gg_wgs84, values, rc, tiff_file)
```


```{r}
shapefile_path <- "C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_BEN_0.shp"

country <- readOGR(shapefile_path)


if (!identical(crs(gg_wgs84_recode), crs(country))) {
  country <- spTransform(country, crs(gg_wgs84_recode))
}

# Recadrer et masquer le raster gg_wgs84_recode selon les frontières du country
gg_wgs84_cropped <- crop(gg_wgs84_recode, extent(country))
gg_wgs84_masked <- mask(gg_wgs84_cropped, country)

rm(shapefile_path, gg_wgs84_recode, gg_wgs84_cropped)

dev.off()

plot(gg_wgs84_masked)
```


```{r}
# Lecture du fichier de données
data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/BEN_pd_2019_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

print(pop)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

print(pop_wgs84)

plot(pop_wgs84)

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country)

rm(data_file, pop, pop_wgs84, pop_wgs84_cropped)

# Vérifier si les résolutions sont les mêmes
if (!all(res(gg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de gg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, gg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

rm(pop_wgs84_masked)

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(gg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

# Multiplier les valeurs des deux rasters
gg_pop <- gg_wgs84_masked * pop_wgs84_resampled

# Afficher le raster résultant avec les contours du country
plot(gg_pop, main="Couverture Pondérée par Densité de Population")
plot(country, add=TRUE, border="darkgrey")

graphics.off()

plot(gg_wgs84_masked)
plot(pop_wgs84_resampled)
plot(gg_pop)


png("plots/gg_pop/chemin_vers_le_plot.png", width = 800, height = 600)
plot(gg_wgs84_masked)
dev.off()

png("plots/gg_pop/chemin_vers_le_plot2.png", width = 800, height = 600)
plot(pop_wgs84_resampled)
dev.off()

png("plots/gg_pop/chemin_vers_le_plot3.png", width = 800, height = 600)
plot(gg_pop, main="Couverture Pondérée par Densité de Population")
dev.off()


```


```{r}

regions <- st_read("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_BEN_2.shp")
regions <- st_make_valid(regions)

mean_gg <- exact_extract(gg_wgs84_masked, regions, 'mean')

regions$mean_gg <- mean_gg


ggplot() +
  geom_sf(data = regions, aes(fill = mean_gg), color = "white") +
  scale_fill_distiller(palette = "YlOrBr", direction = 1, name = "Internet Coverage")+
  theme_minimal() +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
  labs(title = "Benin - Internet Coverage ADM2 - Round 8")


mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

regions$mean_pop <- mean_pop

ggplot() +
  geom_sf(data = regions, aes(fill = mean_pop), color = "white") +
  scale_fill_distiller(palette = "YlOrBr", direction = 1, name = "Pop Density", breaks = c(min(regions$mean_pop), max(regions$mean_pop)), labels = c(0, 1)) +
  theme_minimal() +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
  labs(title = "Benin - Population Density ADM2 - Round 7")


mean_gg_pop <- exact_extract(gg_pop, regions, 'mean')

regions$mean_gg_pop <- mean_gg_pop

ggplot() +
  geom_sf(data = regions, aes(fill = mean_gg_pop), color = "white") +
  scale_fill_distiller(palette = "YlOrBr", direction = 1, name = "Pop Density", breaks = c(min(regions$mean_gg_pop), max(regions$mean_gg_pop)), labels = c(0, 1)) +
  theme_minimal() +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
  labs(title = "Benin - Weighted Population Density ADM2 - Round 7")


regions$pot_gg_pop <- mean_gg_pop/mean_pop

ggplot() +
  geom_sf(data = regions, aes(fill = pot_gg_pop), color = "white") +
  scale_fill_distiller(palette = "YlOrBr", direction = 1, name = "Pop Density", breaks = c(min(regions$pot_gg_pop), max(regions$pot_gg_pop)), labels = c(0, 1)) +
  theme_minimal() +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
  labs(title = "Benin - Weighted Population Density ADM2 - Round 7")

```

```{r}
data_trust_test <- readRDS("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_RDS/final_df5.rds")

capitals <- data_trust_test %>%
  select(caplong, caplat, ISO) %>%
  na.omit() %>%
  rename(longitude = caplong, latitude = caplat)

capitals%<>%
  filter(ISO=="BEN")%>%
  distinct(ISO, .keep_all = TRUE)


png("plots/gg_pop/no_pop_weighting.png", width = 800, height = 600)

#Avant
ggplot() +
  geom_sf(data = regions, aes(fill = mean_gg), color = "white") +
  scale_fill_distiller(palette = "YlOrBr", direction = 1, name = "2G Coverage", breaks = c(min(regions$mean_gg), max(regions$mean_gg)), labels = c(0, 1)) +
  theme_minimal() +
  theme(legend.position = "right", plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
  labs(title = "No Population Weighting")

dev.off()

#Après
png("plots/gg_pop/pop_weighted.png", width = 800, height = 600, dpi=300)

ggplot() +
  geom_sf(data = regions, aes(fill = pot_gg_pop), color = "black") +
  scale_fill_distiller(palette = "YlOrBr", direction = 1, name = "Internet Coverage", breaks = c(min(regions$pot_gg_pop), max(regions$pot_gg_pop)), labels = NULL) +
  geom_point(data = capitals, 
             aes(x = longitude, y = latitude), 
             size = 4, shape = 22, fill = "green", show.legend = FALSE)+
  geom_text(aes(x = 2.5, y = 6.2, label = "Porto-Novo"), color = "black", size = 4, fontface="bold") +
    theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),  
    panel.background = element_blank(),   
    axis.text = element_blank(),         
    axis.ticks = element_blank(),         
    axis.title = element_blank(),
    legend.position = c(1 ,0.35),
    plot.title = element_text(hjust = 0.5, size = 5, face = "bold")
  )

ggsave("plots/gg_pop/pop_weighted3.jpg", width = 8, height = 6, dpi = 300)


dev.off()
```


#3G Data
##2019
###ADM2
*Note pays:
BEN: 2018
BFA: 2014
BWA: /
CMR: 2017
CIV: /
GHA: 2014
GIN: 2012
KEN: 2013
LBR: 2013
MLI: /
MWI: 2014
MOZ: /
NAM: /
NER: 2013
NGA: 2012
SEN: 2015
SLE: 2014
TZA: 2014
UGA: 2013
ZMB: 2014
ZWE: 2015
```{r}
countries_adm2 <- c("BFA","GIN", "LBR", "NER", "SLE", "CMR", "NAM", "GHA","KEN","MWI","NGA","TZA","UGA","ZMB", "ZWE")

#No Botswana, Ivory Coast, Mali ,Togo in 2018


rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

accumulated_results <- data.frame()

for (country in countries_adm2) {

  # Lecture du fichier shapefile
  shapefile <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_", country,"_2.shp")
  regions <- st_read(shapefile)
  regions <- st_make_valid(regions)
  
  tiff_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins_recode/Mobile Coverage Explorer v2019 - GeoTIFF/Data_MCE/ByCountry/MCE_3G/MCE_", country,"3G_2019.tif")
  
ggg <- raster(tiff_file)
ggg_wgs84 <- projectRaster(ggg, crs = CRS("+proj=longlat +datum=WGS84"))
ggg_wgs84_recode <- calc(ggg_wgs84, fun=rc)



shapefile_path <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_",country,"_0.shp")

country_shp <- readOGR(shapefile_path)


if (!identical(crs(ggg_wgs84_recode), crs(country_shp))) {
  country_shp <- spTransform(country_shp, crs(ggg_wgs84_recode))
}

# Recadrer et masquer le raster ggg_wgs84_recode selon les frontières du country
ggg_wgs84_cropped <- crop(ggg_wgs84_recode, extent(country_shp))
ggg_wgs84_masked <- mask(ggg_wgs84_cropped, country_shp)


# Lecture du fichier de données
data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/",country,"_pd_2019_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country_shp))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country_shp)


# Vérifier si les résolutions sont les mêmes
if (!all(res(ggg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de ggg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, ggg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(ggg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

# Multiplier les valeurs des deux rasters
ggg_pop <- ggg_wgs84_masked * pop_wgs84_resampled





mean_ggg <- exact_extract(ggg_wgs84_masked, regions, 'mean')

regions$mean_ggg <- mean_ggg


mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

regions$mean_pop <- mean_pop


mean_ggg_pop <- exact_extract(ggg_pop, regions, 'mean')

regions$mean_ggg_pop <- mean_ggg_pop


regions$pot_ggg_pop <- mean_ggg_pop/mean_pop

regions %<>%
  as.data.frame()

regions %<>%
  rename(ISO=GID_0)%>%
  select(ISO, NAME_2, pot_ggg_pop, mean_ggg_pop, mean_pop, mean_ggg)%>%
  mutate(round=8)

accumulated_results <- rbind(accumulated_results, regions)

}

glimpse(accumulated_results)

accumulated_results%<>%
  rename(pot_ggg_pop_2=pot_ggg_pop,
         mean_ggg_pop_2=mean_ggg_pop,
         mean_pop_2=mean_pop,
         mean_ggg_2=mean_ggg)

data_trust <- readRDS("Data/Data_RDS/final_df5.rds")

data_trust %<>% left_join(accumulated_results, by=c("ISO", "NAME_2", "round"))

data_trust%<>%
  distinct(id_unique, .keep_all = TRUE)
```


##2016
###ADM2

*Note pays:
BEN: 2018
BFA: 2014
BWA: /
CMR: 2017
CIV: /
GHA: 2014
GIN: 2012
KEN: 2013
LBR: 2013
MLI: /
MWI: 2014
MOZ: /
NAM: /
NER: 2013
NGA: 2012
SEN: 2015
SLE: 2014
TZA: 2014
UGA: 2013
ZMB: 2014
ZWE: 2015

```{r}
countries_adm2 <- c("BFA","GIN", "LBR", "NER", "SLE", "GHA","KEN","MWI","NGA","TZA","UGA","ZMB", "ZWE")

#No Botswana, Ivory Coast, Mali ,Togo in 2018

rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

accumulated_results <- data.frame()


for (country in countries_adm2) {

  # Lecture du fichier shapefile
  shapefile <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_", country,"_2.shp")
  regions <- st_read(shapefile)
  regions <- st_make_valid(regions)
  
  tiff_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins_recode/Mobile Coverage Explorer v2016 - GeoTIFF/Data_MCE/ByCountry/MCE_3G/MCE_", country,"3G_2016.tif")
  
ggg <- raster(tiff_file)
ggg_wgs84 <- projectRaster(ggg, crs = CRS("+proj=longlat +datum=WGS84"))
ggg_wgs84_recode <- calc(ggg_wgs84, fun=rc)



shapefile_path <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_",country,"_0.shp")

country_shp <- readOGR(shapefile_path)


if (!identical(crs(ggg_wgs84_recode), crs(country_shp))) {
  country_shp <- spTransform(country_shp, crs(ggg_wgs84_recode))
}

# Recadrer et masquer le raster ggg_wgs84_recode selon les frontières du country
ggg_wgs84_cropped <- crop(ggg_wgs84_recode, extent(country_shp))
ggg_wgs84_masked <- mask(ggg_wgs84_cropped, country_shp)


# Lecture du fichier de données
data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/",country,"_pd_2016_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country_shp))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country_shp)


# Vérifier si les résolutions sont les mêmes
if (!all(res(ggg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de ggg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, ggg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(ggg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

# Multiplier les valeurs des deux rasters
ggg_pop <- ggg_wgs84_masked * pop_wgs84_resampled





mean_ggg <- exact_extract(ggg_wgs84_masked, regions, 'mean')

regions$mean_ggg <- mean_ggg


mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

regions$mean_pop <- mean_pop


mean_ggg_pop <- exact_extract(ggg_pop, regions, 'mean')

regions$mean_ggg_pop <- mean_ggg_pop


regions$pot_ggg_pop <- mean_ggg_pop/mean_pop

regions %<>%
  as.data.frame()

regions %<>%
  rename(ISO=GID_0)%>%
  select(ISO, NAME_2, pot_ggg_pop, mean_ggg_pop, mean_pop, mean_ggg)%>%
  mutate(round=7)

accumulated_results <- rbind(accumulated_results, regions)

}

glimpse(accumulated_results)

accumulated_results%<>%
  rename(pot_ggg_pop_2=pot_ggg_pop,
         mean_ggg_pop_2=mean_ggg_pop,
         mean_pop_2=mean_pop,
         mean_ggg_2=mean_ggg)

data_trust %<>% left_join(accumulated_results, by=c("ISO", "NAME_2", "round"))


glimpse(data_trust)

data_trust %<>%
  mutate(mean_ggg_2 = coalesce(mean_ggg_2.x, mean_ggg_2.y))%>%
  mutate(mean_ggg_pop_2 = coalesce(mean_ggg_pop_2.x, mean_ggg_pop_2.y))%>%
  mutate(mean_pop_2 = coalesce(mean_pop_2.x, mean_pop_2.y))%>%
  mutate(pot_ggg_pop_2 = coalesce(pot_ggg_pop_2.x, pot_ggg_pop_2.y))%>%
  select(-c(mean_ggg_2.x, mean_ggg_2.y, mean_ggg_pop_2.x,mean_ggg_pop_2.y, mean_pop_2.x, mean_pop_2.y, pot_ggg_pop_2.x, pot_ggg_pop_2.y))


data_trust%<>%
  distinct(id_unique, .keep_all = TRUE)

```


##2014
###ADM2
```{r}
countries_adm2 <- c("GIN", "LBR", "NER", "KEN","NGA","UGA", "ZWE")

#No Benin, Botswana, Cameroon, Ivory Coast, Mali, Namibia, Senegal, Togo in 2014

rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

accumulated_results <- data.frame()


for (country in countries_adm2) {

  # Lecture du fichier shapefile
  shapefile <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_", country,"_2.shp")
  regions <- st_read(shapefile)
  regions <- st_make_valid(regions)
  
  tiff_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins_recode/Mobile Coverage Explorer v2014 - GeoTIFF/Data_MCE/ByCountry/MCE_3G/MCE_", country,"3G_2014.tif")
  
ggg <- raster(tiff_file)
ggg_wgs84 <- projectRaster(ggg, crs = CRS("+proj=longlat +datum=WGS84"))
ggg_wgs84_recode <- calc(ggg_wgs84, fun=rc)



shapefile_path <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_",country,"_0.shp")

country_shp <- readOGR(shapefile_path)


if (!identical(crs(ggg_wgs84_recode), crs(country_shp))) {
  country_shp <- spTransform(country_shp, crs(ggg_wgs84_recode))
}

# Recadrer et masquer le raster ggg_wgs84_recode selon les frontières du country
ggg_wgs84_cropped <- crop(ggg_wgs84_recode, extent(country_shp))
ggg_wgs84_masked <- mask(ggg_wgs84_cropped, country_shp)


# Lecture du fichier de données
data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/",country,"_pd_2014_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country_shp))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country_shp)


# Vérifier si les résolutions sont les mêmes
if (!all(res(ggg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de ggg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, ggg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(ggg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

# Multiplier les valeurs des deux rasters
ggg_pop <- ggg_wgs84_masked * pop_wgs84_resampled


mean_ggg <- exact_extract(ggg_wgs84_masked, regions, 'mean')

regions$mean_ggg <- mean_ggg


mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

regions$mean_pop <- mean_pop


mean_ggg_pop <- exact_extract(ggg_pop, regions, 'mean')

regions$mean_ggg_pop <- mean_ggg_pop


regions$pot_ggg_pop <- mean_ggg_pop/mean_pop

regions %<>%
  as.data.frame()

regions %<>%
  rename(ISO=GID_0)%>%
  select(ISO, NAME_2, pot_ggg_pop, mean_ggg_pop, mean_pop, mean_ggg)%>%
  mutate(round=6)

accumulated_results <- rbind(accumulated_results, regions)

}

glimpse(accumulated_results)

accumulated_results%<>%
  rename(pot_ggg_pop_2=pot_ggg_pop,
         mean_ggg_pop_2=mean_ggg_pop,
         mean_pop_2=mean_pop,
         mean_ggg_2=mean_ggg)

data_trust %<>% left_join(accumulated_results, by=c("ISO", "NAME_2", "round"))


glimpse(data_trust)

data_trust %<>%
  mutate(mean_ggg_2 = coalesce(mean_ggg_2.x, mean_ggg_2.y))%>%
  mutate(mean_ggg_pop_2 = coalesce(mean_ggg_pop_2.x, mean_ggg_pop_2.y))%>%
  mutate(mean_pop_2 = coalesce(mean_pop_2.x, mean_pop_2.y))%>%
  mutate(pot_ggg_pop_2 = coalesce(pot_ggg_pop_2.x, pot_ggg_pop_2.y))%>%
  select(-c(mean_ggg_2.x, mean_ggg_2.y, mean_ggg_pop_2.x,mean_ggg_pop_2.y, mean_pop_2.x, mean_pop_2.y, pot_ggg_pop_2.x, pot_ggg_pop_2.y))


data_trust%<>%
  distinct(id_unique, .keep_all = TRUE)

```

#2G Data

##2019
###ADM2

```{r}
countries_adm2 <- c("BEN", "BFA", "BWA", "CMR", "CIV", "GIN", "LBR", "MLI","NAM", "NER", "SLE", "GHA","KEN","MOZ","MWI","NGA","TZA","UGA","ZMB", "ZWE")

#No Senegal, Togo in 2019

rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

accumulated_results <- data.frame()


for (country in countries_adm2) {

  # Lecture du fichier shapefile
  shapefile <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_", country,"_2.shp")
  regions <- st_read(shapefile)
  regions <- st_make_valid(regions)
  
## Etape 1 de Guriev et al.
  
tiff_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins_recode/Mobile Coverage Explorer v2019 - GeoTIFF/Data_MCE/ByCountry/MCE_2G/MCE_", country,"2G_2019.tif")

gg <- raster(tiff_file)
gg_wgs84 <- projectRaster(gg, crs = CRS("+proj=longlat +datum=WGS84"))
gg_wgs84_recode <- calc(gg_wgs84, fun=rc)



shapefile_path <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_",country,"_0.shp")

country_shp <- readOGR(shapefile_path)


if (!identical(crs(gg_wgs84_recode), crs(country_shp))) {
  country_shp <- spTransform(country_shp, crs(gg_wgs84_recode))
}

# Recadrer et masquer le raster gg_wgs84_recode selon les frontières du country
gg_wgs84_cropped <- crop(gg_wgs84_recode, extent(country_shp))
gg_wgs84_masked <- mask(gg_wgs84_cropped, country_shp)


## Etape 2 de Guriev et al.

data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/",country,"_pd_2019_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country_shp))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country_shp)


# Vérifier si les résolutions sont les mêmes
if (!all(res(gg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de gg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, gg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(gg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

## Etape 3 de Guriev et al.
gg_pop <- gg_wgs84_masked * pop_wgs84_resampled


## Etape 4 de Guriev et al.
mean_gg_pop <- exact_extract(gg_pop, regions, 'mean')


## Etape 5 de Guriev et al.
mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

## Etape 6 de Guriev et al.
regions$mean_gg_pop <- mean_gg_pop
regions$mean_pop <- mean_pop



## Etape 7 de Guriev et al.
regions$pot_gg_pop <- mean_gg_pop/mean_pop


## Moyenne couverture 2G non pondérée par la densité de population
mean_gg <- exact_extract(gg_wgs84_masked, regions, 'mean')
regions$mean_gg <- mean_gg


regions %<>%
  as.data.frame()

regions %<>%
  rename(ISO=GID_0)%>%
  select(ISO, NAME_2, pot_gg_pop, mean_gg_pop, mean_pop, mean_gg)%>%
  mutate(round=8)

accumulated_results <- rbind(accumulated_results, regions)

}

glimpse(accumulated_results)

accumulated_results%<>%
  rename(pot_gg_pop_2=pot_gg_pop,
         mean_gg_pop_2=mean_gg_pop,
         mean_pop_2=mean_pop,
         mean_gg_2=mean_gg)

data_trust %<>% left_join(accumulated_results, by=c("ISO", "NAME_2", "round"))


glimpse(data_trust)

data_trust %<>%
  mutate(mean_pop_2 = coalesce(mean_pop_2.x, mean_pop_2.y))%>%
  select(-c(mean_pop_2.x, mean_pop_2.y))


data_trust%<>%
  distinct(id_unique, .keep_all = TRUE)


```

##2016
###ADM2

```{r}
countries_adm2 <- c("BEN", "BFA", "BWA", "CMR", "CIV", "GIN", "LBR", "MLI","NAM", "NER", "SLE", "GHA","KEN","MOZ","MWI","NGA","TZA","UGA","ZMB", "ZWE")
#No Senegal, Togo in 2016

rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

accumulated_results <- data.frame()


for (country in countries_adm2) {

  # Lecture du fichier shapefile
  shapefile <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_", country,"_2.shp")
  regions <- st_read(shapefile)
  regions <- st_make_valid(regions)
  
## Etape 1 de Guriev et al.
  
tiff_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins_recode/Mobile Coverage Explorer v2016 - GeoTIFF/Data_MCE/ByCountry/MCE_2G/MCE_", country,"2G_2016.tif")

gg <- raster(tiff_file)
gg_wgs84 <- projectRaster(gg, crs = CRS("+proj=longlat +datum=WGS84"))
gg_wgs84_recode <- calc(gg_wgs84, fun=rc)



shapefile_path <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_",country,"_0.shp")

country_shp <- readOGR(shapefile_path)


if (!identical(crs(gg_wgs84_recode), crs(country_shp))) {
  country_shp <- spTransform(country_shp, crs(gg_wgs84_recode))
}

# Recadrer et masquer le raster gg_wgs84_recode selon les frontières du country
gg_wgs84_cropped <- crop(gg_wgs84_recode, extent(country_shp))
gg_wgs84_masked <- mask(gg_wgs84_cropped, country_shp)


## Etape 2 de Guriev et al.

data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/",country,"_pd_2016_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country_shp))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country_shp)


# Vérifier si les résolutions sont les mêmes
if (!all(res(gg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de gg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, gg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(gg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

## Etape 3 de Guriev et al.
gg_pop <- gg_wgs84_masked * pop_wgs84_resampled


## Etape 4 de Guriev et al.
mean_gg_pop <- exact_extract(gg_pop, regions, 'mean')


## Etape 5 de Guriev et al.
mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

## Etape 6 de Guriev et al.
regions$mean_gg_pop <- mean_gg_pop
regions$mean_pop <- mean_pop



## Etape 7 de Guriev et al.
regions$pot_gg_pop <- mean_gg_pop/mean_pop


## Moyenne couverture 2G non pondérée par la densité de population
mean_gg <- exact_extract(gg_wgs84_masked, regions, 'mean')
regions$mean_gg <- mean_gg


regions %<>%
  as.data.frame()

regions %<>%
  rename(ISO=GID_0)%>%
  select(ISO, NAME_2, pot_gg_pop, mean_gg_pop, mean_pop, mean_gg)%>%
  mutate(round=7)

accumulated_results <- rbind(accumulated_results, regions)

}

glimpse(accumulated_results)

accumulated_results%<>%
  rename(pot_gg_pop_2=pot_gg_pop,
         mean_gg_pop_2=mean_gg_pop,
         mean_pop_2=mean_pop,
         mean_gg_2=mean_gg)

data_trust %<>% left_join(accumulated_results, by=c("ISO", "NAME_2", "round"))


glimpse(data_trust)

data_trust %<>%
  mutate(mean_gg_2 = coalesce(mean_gg_2.x, mean_gg_2.y))%>%
  mutate(mean_gg_pop_2 = coalesce(mean_gg_pop_2.x, mean_gg_pop_2.y))%>%
  mutate(mean_pop_2 = coalesce(mean_pop_2.x, mean_pop_2.y))%>%
  mutate(pot_gg_pop_2 = coalesce(pot_gg_pop_2.x, pot_gg_pop_2.y))%>%
  select(-c(mean_gg_2.x, mean_gg_2.y, mean_gg_pop_2.x,mean_gg_pop_2.y, mean_pop_2.x, mean_pop_2.y, pot_gg_pop_2.x, pot_gg_pop_2.y))


data_trust%<>%
  distinct(id_unique, .keep_all = TRUE)

```


##2014
###ADM2

```{r}
countries_adm2 <- c("BEN", "BFA", "BWA", "CMR", "CIV", "GIN", "LBR", "MLI","NAM", "NER", "SLE", "GHA","KEN","MOZ","MWI","NGA","TZA","UGA","ZMB", "ZWE")

#No Senegal, Togo in 2014

rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

accumulated_results <- data.frame()


for (country in countries_adm2) {

  # Lecture du fichier shapefile
  shapefile <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_", country,"_2.shp")
  regions <- st_read(shapefile)
  regions <- st_make_valid(regions)
  
  tiff_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins_recode/Mobile Coverage Explorer v2014 - GeoTIFF/Data_MCE/ByCountry/MCE_2G/MCE_", country,"2G_2014.tif")
  
gg <- raster(tiff_file)
gg_wgs84 <- projectRaster(gg, crs = CRS("+proj=longlat +datum=WGS84"))
gg_wgs84_recode <- calc(gg_wgs84, fun=rc)



shapefile_path <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_",country,"_0.shp")

country_shp <- readOGR(shapefile_path)


if (!identical(crs(gg_wgs84_recode), crs(country_shp))) {
  country_shp <- spTransform(country_shp, crs(gg_wgs84_recode))
}

# Recadrer et masquer le raster gg_wgs84_recode selon les frontières du country
gg_wgs84_cropped <- crop(gg_wgs84_recode, extent(country_shp))
gg_wgs84_masked <- mask(gg_wgs84_cropped, country_shp)


# Lecture du fichier de données
data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/",country,"_pd_2014_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country_shp))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country_shp)


# Vérifier si les résolutions sont les mêmes
if (!all(res(gg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de gg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, gg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(gg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

# Multiplier les valeurs des deux rasters
gg_pop <- gg_wgs84_masked * pop_wgs84_resampled





mean_gg <- exact_extract(gg_wgs84_masked, regions, 'mean')

regions$mean_gg <- mean_gg


mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

regions$mean_pop <- mean_pop


mean_gg_pop <- exact_extract(gg_pop, regions, 'mean')

regions$mean_gg_pop <- mean_gg_pop


regions$pot_gg_pop <- mean_gg_pop/mean_pop

regions %<>%
  as.data.frame()

regions %<>%
  rename(ISO=GID_0)%>%
  select(ISO, NAME_2, pot_gg_pop, mean_gg_pop, mean_pop, mean_gg)%>%
  mutate(round=6)

accumulated_results <- rbind(accumulated_results, regions)

}

glimpse(accumulated_results)

accumulated_results%<>%
  rename(pot_gg_pop_2=pot_gg_pop,
         mean_gg_pop_2=mean_gg_pop,
         mean_pop_2=mean_pop,
         mean_gg_2=mean_gg)

data_trust %<>% left_join(accumulated_results, by=c("ISO", "NAME_2", "round"))


glimpse(data_trust)

data_trust %<>%
  mutate(mean_gg_2 = coalesce(mean_gg_2.x, mean_gg_2.y))%>%
  mutate(mean_gg_pop_2 = coalesce(mean_gg_pop_2.x, mean_gg_pop_2.y))%>%
  mutate(mean_pop_2 = coalesce(mean_pop_2.x, mean_pop_2.y))%>%
  mutate(pot_gg_pop_2 = coalesce(pot_gg_pop_2.x, pot_gg_pop_2.y))%>%
  select(-c(mean_gg_2.x, mean_gg_2.y, mean_gg_pop_2.x,mean_gg_pop_2.y, mean_pop_2.x, mean_pop_2.y, pot_gg_pop_2.x, pot_gg_pop_2.y))


data_trust%<>%
  distinct(id_unique, .keep_all = TRUE)

```




##2011
###ADM2

```{r}
countries_adm2 <- c("BEN", "BFA", "BWA", "CMR", "CIV", "GIN", "LBR", "MLI","NAM", "NER", "SLE", "GHA","KEN","MOZ","MWI","NGA","TZA","UGA","ZMB")
#No Senegal, Togo in 2011


rc <- function(x) {
  ifelse(is.na(x), 0,
         ifelse(x < 1, 0,
                ifelse(x >= 1, 1, NA)))
}

accumulated_results <- data.frame()


for (country in countries_adm2) {

  # Lecture du fichier shapefile
  shapefile <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_", country,"_2.shp")
  regions <- st_read(shapefile)
  regions <- st_make_valid(regions)
  
  tiff_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/collins_recode/Mobile Coverage Explorer v2011 - GeoTIFF/Data_MCE/ByCountry/MCE_2G/MCE_", country,"2G_2011.tif")
  
gg <- raster(tiff_file)
gg_wgs84 <- projectRaster(gg, crs = CRS("+proj=longlat +datum=WGS84"))
gg_wgs84_recode <- calc(gg_wgs84, fun=rc)



shapefile_path <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/gadm41_",country,"_0.shp")

country_shp <- readOGR(shapefile_path)


if (!identical(crs(gg_wgs84_recode), crs(country_shp))) {
  country_shp <- spTransform(country_shp, crs(gg_wgs84_recode))
}

# Recadrer et masquer le raster gg_wgs84_recode selon les frontières du country
gg_wgs84_cropped <- crop(gg_wgs84_recode, extent(country_shp))
gg_wgs84_masked <- mask(gg_wgs84_cropped, country_shp)


# Lecture du fichier de données
data_file <- paste0("C:/Users/Redha CHABA/Documents/Working paper/Trust/Script/data/data_Raw/",country,"_pd_2011_1km_UNadj_ASCII_XYZ.csv")

pop <- raster(data_file)

pop_wgs84 <- projectRaster(pop, crs = CRS("+proj=longlat +datum=WGS84"))

# Recadrer et masquer le raster pop_wgs84 selon les frontières du country
pop_wgs84_cropped <- crop(pop_wgs84, extent(country_shp))
pop_wgs84_masked <- mask(pop_wgs84_cropped, country_shp)


# Vérifier si les résolutions sont les mêmes
if (!all(res(gg_wgs84_masked) == res(pop_wgs84_masked))) {
  # Ajuster la résolution de pop_wgs84_masked à celle de gg_wgs84_masked
  pop_wgs84_resampled <- resample(pop_wgs84_masked, gg_wgs84_masked, method = "bilinear")
} else {
  pop_wgs84_resampled <- pop_wgs84_masked
}

# Vérifier de nouveau les étendues et les résolutions
if (!compareRaster(gg_wgs84_masked, pop_wgs84_resampled)) {
  stop("Les rasters n'ont pas la même résolution et/ou la même étendue après ajustement.")
}

# Multiplier les valeurs des deux rasters
gg_pop <- gg_wgs84_masked * pop_wgs84_resampled





mean_gg <- exact_extract(gg_wgs84_masked, regions, 'mean')

regions$mean_gg <- mean_gg


mean_pop <- exact_extract(pop_wgs84_resampled, regions, 'mean')

regions$mean_pop <- mean_pop


mean_gg_pop <- exact_extract(gg_pop, regions, 'mean')

regions$mean_gg_pop <- mean_gg_pop


regions$pot_gg_pop <- mean_gg_pop/mean_pop

regions %<>%
  as.data.frame()

regions %<>%
  rename(ISO=GID_0)%>%
  select(ISO, NAME_2, pot_gg_pop, mean_gg_pop, mean_pop, mean_gg)%>%
  mutate(round=5)

accumulated_results <- rbind(accumulated_results, regions)

}

glimpse(accumulated_results)

accumulated_results%<>%
  rename(pot_gg_pop_2=pot_gg_pop,
         mean_gg_pop_2=mean_gg_pop,
         mean_pop_2=mean_pop,
         mean_gg_2=mean_gg)

data_trust %<>% left_join(accumulated_results, by=c("ISO", "NAME_2", "round"))


glimpse(data_trust)

data_trust %<>%
  mutate(mean_gg_2 = coalesce(mean_gg_2.x, mean_gg_2.y))%>%
  mutate(mean_gg_pop_2 = coalesce(mean_gg_pop_2.x, mean_gg_pop_2.y))%>%
  mutate(mean_pop_2 = coalesce(mean_pop_2.x, mean_pop_2.y))%>%
  mutate(pot_gg_pop_2 = coalesce(pot_gg_pop_2.x, pot_gg_pop_2.y))%>%
  select(-c(mean_gg_2.x, mean_gg_2.y, mean_gg_pop_2.x,mean_gg_pop_2.y, mean_pop_2.x, mean_pop_2.y, pot_gg_pop_2.x, pot_gg_pop_2.y))


data_trust%<>%
  distinct(id_unique, .keep_all = TRUE)


```


```{r}
data_trust%<>%
    mutate(pot_cvg_2=ifelse(is.na(pot_ggg_pop_2), pot_gg_pop_2, pot_ggg_pop_2))

saveRDS(data_trust, file="Data/Data_RDS/final_df5.rds")
write_dta(data_trust, "Data/Data_dta/final_df5.dta")

```
